---
layout: post
title: "the architecture and design of a publish subscribe messaging system tailored for big data collecting and analytics"
date: 2013-03-27 16:30
comments: true
categories: [design, luxun]
keywords: distributed, persistent, pub-sub messaging system
description: The Architecture and Design of a Publish & Subscribe Messaging System Tailored for Big Data Collecting and Analytics.
---

#Overview

With the advent of big data era, we are facing more and more challenges from big data collecting and analytics requirements. Typical big data or activity stream includes but not limited to:

>* Logs generated by frontend applications or backend services
* User behavior data
* Application or system performance trace
* Business, application or system metrics data.
* Events that need immediate action.

The Luxun messaging system is just tailored for big data collecting and analytics scenario, following are the main design objectives of Luxun messaging system:

<!--more-->

>* ***Fast and High-Throughput*** : This is the top priority feature, without this capability, the system will be easily overwhelmed by flooding data continuously generated by hundreds or thousands of machines, it is expected that both enqueue and dequeue speed should be close to O(1) memory access, and that even with modest hardware Luxun can support hundreds of thousands of messages per second.
* ***Persistent and Durable*** : Real business value can be derived from big data, so any data lose should be avoided as far as possible. Also, nowadays backend system maintenance(or even crash) is common, Luxun should persist messages on disk longer than the maintenance(or system recovery) window, to let backend systems continue to consume messages when they are up again. Regarding durability, Luxun should ensure the persistence of the message even the service process crashes.
* ***Separation of Producers and Consumers*** : Luxun should separate messaging producers and consumers using pub-sub style exchange pattern, each one can work without knowing the existence of the others, such kind of loosely coupled architecture can make the whole system robust, horizontal scalable, and easy to maintain.
* ***Realtime*** : Messages produced by producer threads should be immediately visible to consumer threads, this feature is critical to event based system like Complex Event Processing(CEP) system.
* ***Distributed*** : Luxun should explicitly support partitioning messages over Luxun servers and distributing consumption over a cluster of consumer machines while maintaining per-partition ordering semantics.
* ***Multiple Client Support*** : Luxun system should support easy integration of clients from different kinds of platforms(such as Java, .Net, PHP, Ruby, Python, etc), it's desirable that producers and consumers can be auto-generated from Luxun service interface, by leveraging technology like Thrift RPC.
* ***Flexible consuming semantics*** : Luxun should support typical consume once queue, fanout queue, and provides more flexible consuming mechanism like consuming by index.
* ***Light Weight*** : The footprint of Luxun binary should be light, and the interface exposed should be simple and be understandable by normal user. Zookeeper like distributed coordination should be avoided since many small or medium scale companies still can't afford it, and the learning curve of zookeeker to average developers is still steep.

Luxun makes a unified big data platform(or pipeline) possible, as illustrated in the figure below:

{% img center /images/luxun/arch-1.png 600 800 %}

The figure shows a typical big data collecting and analytics scenario supported by Luxun messaging system:  
At the producing side, there are different kinds of producers, such as:  

>* Frontend web applications producing application logs.
* External tracking proxies producing web analytics logs.
* Backend services producing service invocation trace logs.

At the consuming side, there are different kinds of consumers, such as:

>* Offline consumers consuming messages and storing them in Hadoop or traditional Data Warehouse for offline analysis.
* Near realtime consumers consuming messages and store them in HBase or Cassandra for near realtime analytics.
* Realtime consumers filter messages in in-memory DB and trigger alert events to related groups.

#Basic Concepts:
>1. ***Topic*** : Logically it's a named place to send messages to or to consume messages from, physically it's a persistent queue.
2. ***Broker*** : Aka Luxun server.
3. ***Message*** : Datum to produce or consume
4. ***Producer*** : A role which will send messages to topics.
5. ***Consumer*** : A role which will consume messages from topics.
6. ***Consumer Group*** : A group of consumers that will receive only one copy of a message from a topic(or more).
 

# Overall Architecture

{% img center /images/luxun/arch-2.png 600 800 %}




Luxun has a simple architecture, the main components of a broker are:

>1. ***Persistent Queue*** : Physical implementation of logic topic, internally use memory mapped file, automatic paging and swapping algorithm, sliding window, index based access for fast queue operation while use memory in an efficient way.
2. ***Thrift based Interface*** : Simple RPC based API exposing queue service to external clients.
3. ***Producer Client*** : Wrapper around Luxun producing API, provides simplified interface for developers, also provides advanced partitioning, batching, compression and asynchronous producing features.
4. ***Consumer Client*** : Wrapper around Luxun consuming API, provides simplified and stream style consuming interface for developers, supporting advanced distributed consuming,  multi-threads concurrent consuming, group consuming features.
5. ***Management and Monitoring***: Server management and JMX based monitoring interface.


# The Core Principle



# Luxun vs Apache Kafka - the Main Differences


##Contributions
Luxun borrowed design ideas and adapted source from following open source projects:

>1. [Apache Kafka](http://kafka.apache.org/index.html), a distributed publish-subscribe messaging system using Scala as implementation language.
2. [Jafka](https://github.com/adyliu/jafka), a Kafka clone using Java as implementation language.
3. [Java Chronicel](https://github.com/peter-lawrey/Java-Chronicle), an ultra low latency, high throughput, persisted, messaging and event driven in memory database. using memory mapped file and index based access mode, implemented in Java.
4. [fqueue](http://code.google.com/p/fqueue/), fast and persistent queue based on memory mapped file and paging algorithm, implemented in Java.
5. [ashes-queue](http://code.google.com/p/ashes-queue/), FIFO queue based on memory mapped file and paging algorithm, implemented in Java.
6. [Kestrel](https://github.com/robey/kestrel), a simple, distributed message queue system implemented in Scala, supporting reliable, loosely ordered message queue.

Many thanks to the authors of these open source projects!


 




  
