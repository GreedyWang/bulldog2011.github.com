<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: design | Abstraction Builder]]></title>
  <link href="http://bulldog2011.github.com/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://bulldog2011.github.com/"/>
  <updated>2013-03-28T19:42:53+08:00</updated>
  <id>http://bulldog2011.github.com/</id>
  <author>
    <name><![CDATA[Bulldog]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[the architecture and design of a publish subscribe messaging system tailored for big data collecting and analytics]]></title>
    <link href="http://bulldog2011.github.com/blog/2013/03/27/the-architecture-and-design-of-a-pub-sub-messaging-system/"/>
    <updated>2013-03-27T16:30:00+08:00</updated>
    <id>http://bulldog2011.github.com/blog/2013/03/27/the-architecture-and-design-of-a-pub-sub-messaging-system</id>
    <content type="html"><![CDATA[<h1>Overview</h1>

<p>With the advent of big data era, we are facing more and more challenges from big data collecting and analytics requirements. Typical big data or activity stream includes but not limited to:</p>

<blockquote><ul>
<li>Logs generated by frontend applications or backend services</li>
<li>User behavior data</li>
<li>Application or system performance trace</li>
<li>Business, application or system metrics data.</li>
<li>Events that need immediate action.</li>
</ul>
</blockquote>

<p>The Luxun messaging system is just tailored for big data collecting and analytics scenario, following are the main design objectives of Luxun messaging system:</p>

<!--more-->


<blockquote><ul>
<li><strong><em>Fast and High-Throughput</em></strong> : This is the top priority feature, without this capability, the system will be easily overwhelmed by flooding data continuously generated by hundreds or thousands of machines, it is expected that both enqueue and dequeue speed should be close to O(1) memory access, and that even with modest hardware Luxun can support hundreds of thousands of messages per second.</li>
<li><strong><em>Persistent and Durable</em></strong> : Real business value can be derived from big data, so any data lose should be avoided as far as possible. Also, nowadays backend system maintenance(or even crash) is common, Luxun should persist messages on disk longer than the maintenance(or system recovery) window, to let backend systems continue to consume messages when they are up again. Regarding durability, Luxun should ensure the persistence of the message even the service process crashes.</li>
<li><strong><em>Separation of Producers and Consumers</em></strong> : Luxun should separate messaging producers and consumers using pub-sub style exchange pattern, each one can work without knowing the existence of the others, such kind of loosely coupled architecture can make the whole system robust, horizontal scalable, and easy to maintain.</li>
<li><strong><em>Realtime</em></strong> : Messages produced by producer threads should be immediately visible to consumer threads, this feature is critical to event based system like Complex Event Processing(CEP) system.</li>
<li><strong><em>Distributed</em></strong> : Luxun should explicitly support partitioning messages over Luxun servers and distributing consumption over a cluster of consumer machines while maintaining per-partition ordering semantics.</li>
<li><strong><em>Multiple Client Support</em></strong> : Luxun system should support easy integration of clients from different kinds of platforms(such as Java, .Net, PHP, Ruby, Python, etc), it's desirable that producers and consumers can be auto-generated from Luxun service interface, by leveraging technology like Thrift RPC.</li>
<li><strong><em>Flexible consuming semantics</em></strong> : Luxun should support typical consume once queue, fanout queue, and provides more flexible consuming mechanism like consuming by index.</li>
<li><strong><em>Light Weight</em></strong> : The footprint of Luxun binary should be light, and the interface exposed should be simple and be understandable by normal user. Zookeeper like distributed coordination should be avoided since many small or medium scale companies still can't afford it, and the learning curve of zookeeker to average developers is still steep.</li>
</ul>
</blockquote>

<p>Luxun makes a unified big data platform(or pipeline) possible, as illustrated in the figure below:</p>

<p><img class="center" src="/images/luxun/arch-1.png" width="600" height="800"></p>

<p>The figure shows a typical big data collecting and analytics scenario supported by Luxun messaging system:<br/>
At the producing side, there are different kinds of producers, such as:</p>

<blockquote><ul>
<li>Frontend web applications producing application logs.</li>
<li>External tracking proxies producing web analytics logs.</li>
<li>Backend services producing service invocation trace logs.</li>
</ul>
</blockquote>

<p>At the consuming side, there are different kinds of consumers, such as:</p>

<blockquote><ul>
<li>Offline consumers consuming messages and storing them in Hadoop or traditional Data Warehouse for offline analysis.</li>
<li>Near realtime consumers consuming messages and store them in HBase or Cassandra for near realtime analytics.</li>
<li>Realtime consumers filter messages in in-memory DB and trigger alert events to related groups.</li>
</ul>
</blockquote>

<h1>Basic Concepts:</h1>

<blockquote><ol>
<li><strong><em>Topic</em></strong> : Logically it's a named place to send messages to or to consume messages from, physically it's a persistent queue.</li>
<li><strong><em>Broker</em></strong> : Aka Luxun server.</li>
<li><strong><em>Message</em></strong> : Datum to produce or consume</li>
<li><strong><em>Producer</em></strong> : A role which will send messages to topics.</li>
<li><strong><em>Consumer</em></strong> : A role which will consume messages from topics.</li>
<li><strong><em>Consumer Group</em></strong> : A group of consumers that will receive only one copy of a message from a topic(or more).</li>
</ol>
</blockquote>

<h1>Overall Architecture</h1>

<p><img class="center" src="/images/luxun/arch-2.png" width="600" height="800"></p>

<p>Luxun has a simple architecture, the main components of a broker are:</p>

<blockquote><ol>
<li><strong><em>Persistent Queue</em></strong> : Physical implementation of logic topic, internally use memory mapped file, automatic paging and swapping algorithm, sliding window, index based access for fast queue operation while use memory in an efficient way.</li>
<li><strong><em>Thrift based Interface</em></strong> : Simple RPC based API exposing queue service to external clients.</li>
<li><strong><em>Producer Client</em></strong> : Wrapper around Luxun producing API, provides simplified interface for developers, also provides advanced partitioning, batching, compression and asynchronous producing features.</li>
<li><strong><em>Consumer Client</em></strong> : Wrapper around Luxun consuming API, provides simplified and stream style consuming interface for developers, supporting advanced distributed consuming,  multi-threads concurrent consuming, group consuming features.</li>
<li><strong><em>Management and Monitoring</em></strong>: Server management and JMX based monitoring interface.</li>
</ol>
</blockquote>

<h1>The Core Principle</h1>

<p>The core principle of a fast while persistent queue system like Luxun is from a key observation that <strong><em><a href="http://queue.acm.org/detail.cfm?id=1563874">sequential disk read can be comparable to or even faster than random memory read</a></em></strong>, see a comparison figure below:</p>

<p><img class="center" src="/images/luxun/core_principle.png" width="600" height="800"></p>

<p>So if we can effectively organize the disk access pattern, then we can get fast performance comparable to memory which still have persistence. Queue is a rear append(or append only) and front read data structure, a nature fit to be implemented in sequential disk access mode.</p>

<h1>The Design of the Persistent Queue</h1>

<h3>Logical View</h3>

<p>The logic view of the persistent queue is fairly simple and intuitive, it's just like a big array, see figure below:</p>

<p><img class="center" src="/images/luxun/queue_logical_view.png" width="400" height="600"></p>

<p>you can access the queue using array like index, one special thing is that the index is of type long(in typical programming language, array index is of type int), so the queue can accomodate huge amount of data, only limited by available disk space. You may also think of the queue as a circular queue as shown in figure above, since the queue will wrap around when the long.max index is reached, (although in practice, we don't think current application will get chance to reach the long.max index:)).</p>

<p>With simple array like abstraction, we can implement queue semantics with ease:</p>

<ol>
<li>For a typical consume once queue, we just need one rear pointer pointing to the queue rear index, aka the next to be appended index, another pointer pointing to the queue front index, aka the next to be consumed index. When an item is produced into the queue, we add the data in the queue then advance the rear index, when an item is consumed from the queue, we fetch the data in the queue then advance the front index. In this case, multi-threads can concurrently produce into the queue, the queue internally will sync the append operation, and multi-threads can concurrently consume(by contention) the queue, and every item will only be consumed by one thread once. see figure below.</li>
<li>For a fanout queue, we also just need one rear pointer pointing to the queue rear index, aka the next to be appended index, but on the consuming side, we let the queue maintain one queue front index for every fanout group, in other word, the fanout semantics is implemented in Luxun by letting Luxun server to maintain consuming state for every fanout group. In such case, multi-threads can concurrently and independently consume the queue, and every item will be consumed multiple times by different consumers as long as they belong to different consumer group(or fanout group). see figure below.</li>
</ol>


<p>By the way, consume once queue is just a special case of fanout queue, so it's not necessary for luxun to provide a separate consume one queue, as long as fanout queue has been provided.</p>

<p>In summary, Luxun queue is an append only queue, means at producing side, item can only be appended into the queue, while at the consuming side, flexible queue consuming semantics are provided by array like index access model and state maintained on server side.</p>

<p>Note, the Luxun queue service even expose the index based queue access interface to user, in case some user may need more flexible queue semantics, for example, to support transactional queue semantics by committing and saving index in DB or Zookeeper. It's even possible to consume the queue randomly by index, although there may have performance issue in such case.</p>

<h1>Luxun vs Apache Kafka - the Main Differences</h1>

<p>Although Luxun borrowed many design ideas from Apache Kafka, Luxun is not a simple clone of Kafka, it has some obvious differentiating factors:</p>

<blockquote><ol>
<li>Luxun is based on <a href="http://en.wikipedia.org/wiki/Memory-mapped_file">Memory Mapped file</a>, while Kafka is based on filesystem and OS page cache, memory mapped file is a natural bridge between volatile memory and persistent disk, hence it will have better throughput, memory mapped file also has following unique features:

<ul>
<li>Message appended by producer thread will be immediately visible to consumer threads, even producer thread hasn't flushed the message explicitly, this makes realtime consuming possible.</li>
<li>OS will ensure the message persistence even the process crashes and there is no explicit flush before the crash.</li>
<li>In Java implementation, memory mapped file dose not use heap memory directly, so the GC impact is limited.</li>
</ul>
</li>
<li>Luxun leveraged <a href="http://thrift.apache.org/">Thrift RPC</a> as communication layer, while Kafka built its custom NIO communication layer and messaging protocol, custom NIO layer may have better performance, while Thrift makes generating communication infrastructure and cross-language clients(producer or consumer) fairy simple, this is a typical maintainability over performance design decision.</li>
<li>Luxun message consuming is index(array like) based, while Kafka message consuming is offset based, we believe index access mode can simplify design and can separate error domain better than offset.</li>
<li>Luxun uses simple and random distribution mechanism for scalability, similar to Kestrel, each server handles a set of reliable, ordered message queues. When you put a cluster of these server together, with no cross communication, and pick a server at random whenever you do a <code>produce</code> or <code>consume</code>, you end up with a reliable, loosely ordered message queue(in many situations, loose ordering is sufficient). On the other hand, Kafka relies on Zookeeper for distributed coordination, We believe Zookeeper is still too heavy-weight for small to medium sized companies(the main targets of Luxun), and the learning curve is still steep for average developers. Of cause, Luxun has extension point left for future possible Zookeeper integration.</li>
<li>Luxun only supports server level partitioning - partition a topic on different servers, while Kafka supports partitioning within a topic. Our performance test show partitioning within a topic has no performance gain, at the same time, it makes design complex.</li>
</ol>
</blockquote>

<p>The difference above is just difference, no one is better than the other, Luxun and Kafka have different architectural objectives,  different target user and applications.</p>

<h2>Contributions</h2>

<p>Luxun borrowed design ideas and adapted source from following open source projects:</p>

<blockquote><ol>
<li><a href="http://kafka.apache.org/index.html">Apache Kafka</a>, a distributed publish-subscribe messaging system using Scala as implementation language.</li>
<li><a href="https://github.com/adyliu/jafka">Jafka</a>, a Kafka clone using Java as implementation language.</li>
<li><a href="https://github.com/peter-lawrey/Java-Chronicle">Java Chronicel</a>, an ultra low latency, high throughput, persisted, messaging and event driven in memory database. using memory mapped file and index based access mode, implemented in Java.</li>
<li><a href="http://code.google.com/p/fqueue/">fqueue</a>, fast and persistent queue based on memory mapped file and paging algorithm, implemented in Java.</li>
<li><a href="http://code.google.com/p/ashes-queue/">ashes-queue</a>, FIFO queue based on memory mapped file and paging algorithm, implemented in Java.</li>
<li><a href="https://github.com/robey/kestrel">Kestrel</a>, a simple, distributed message queue system implemented in Scala, supporting reliable, loosely ordered message queue.</li>
</ol>
</blockquote>

<p>Many thanks to the authors of these open source projects!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Design of A Big, Fast, and Persistent Queue]]></title>
    <link href="http://bulldog2011.github.com/blog/2013/01/23/big-queue-design/"/>
    <updated>2013-01-23T20:55:00+08:00</updated>
    <id>http://bulldog2011.github.com/blog/2013/01/23/big-queue-design</id>
    <content type="html"><![CDATA[<h1>Why a Big Queue?</h1>

<p>This is a big data era, we are always facing challenge to find insights in big data. Last time, I have worked on the architecture and design of a large scale logging, tracing, monitoring and analytics platform, the core of the platform is a log collecting system and the core of the collector is a big queue, see figure below:</p>

<!-- more -->


<p><img class="center" src="/images/bigqueue/log_collector.png" width="400" height="400"></p>

<p>The figure above looks like a typical producing and consuming scenario, the big queue works like a broker, at the left side of the queue, there are many agents deployed on application servers, the agents work just like producers, they continuously collect log data on application servers and push them to the big queue, on the right side of the big queue, there are several analysis systems, the analysis systems work just like consumers, they continuously pull log data from the queue, analyze  and store them into the backend. If you are interested in an industrial log collecting product built on this architecture, please refer to <a href="http://kafka.apache.org/">apache kafka</a>.</p>

<p>Queue is a natural fit for log data collecting scenario, by leveraging queue, consumers and producers are decoupled, both sides can work without knowing the existing of other side, consumers and producers can be added or removed as needed without affecting existing ones.</p>

<h1>The Requirements</h1>

<p>Basically, we need the big queue to be:</p>

<ul>
<li><strong>FAST &amp; THREAD SAFE</strong>    <br/>
The system needs to collect logs from more than 1000 production machines, they may produce more than 100,000 logs per second(average size is 1KB), this is equal to more than 100MB per second, if the big queue can’t keep up, logs will be lost. To further improve the throughout, we want all producers and consumers to work concurrently, so the queue needs to work in a thread safe manner, otherwise, there will be data lose or corruption.</li>
<li><strong>BIG &amp; PERSISTENT</strong> <br/>
Daily logs will be at TB level, the queue should have the capacity to store up to one week’s logs,
In case any of the analysis system is down(for example, periodical maintenance or even crash), the queue should continue to store logs for backend system to consume later when they are up again. Also, if the big queue itself is down, the logs already stored should survive since they are persistent, when the queue is up again, it should continue to serve the consumers.</li>
<li><strong>MEMORY EFFICIENT</strong><br/>
Compared with big disk storage, current computer system is still shortage of physical memory, usually, memory will be less than 32GB on a commodity machine. We need the queue to use memory efficiently though it needs to handle logs more than 100MB per second and at TB level daily.</li>
</ul>


<h1>The Design Thinking Flow</h1>

<p>Below is a simple and elegant design of the big queue I come up with to meet the requirements and challenges above:</p>

<p><img class="center" src="/images/bigqueue/bigqueue_abstraction_layers.png" width="300" height="300"></p>

<p>Usually, when I design something, I follow a top-down abstract thinking flow: as I learned in data structure course in college long ago, a queue data structure is usually built on an array data structure, so before I can build a queue I need to build an array first, the array I need should have following characters: first, it should be as fast as in memory access; second, it should be disk backed(hence it will be big and persistent). Seems there is contradiction between these two characters: if you need something fast, you need to put it in memory which is volatile and only has limited capacity, if you need something big and persistent, you need to put it on disk which has much slower access speed than physical memory, is there a technology to resolve these two contradictions? After an intensive research, I finally found memory mapped file which seems a natural bridge between psychical memory and disk, if you need background about memory mapped file, <a href="http://www.kdgregory.com/index.php?page=java.byteBuffer">here</a> and <a href="http://vanillajava.blogspot.co.uk/2012/03/presentation-on-using-shared-memory-in.html">here</a> are two good references. Now let’s continue the top-down thinking flow, before I can build a big array, I need to build a data structure called memory mapped page which can bridge the gap between speed and capacity, at the same time, I need some auxiliary structures to manage mapped pages in a memory efficient way, in the design figure above, these auxiliary structures are called mapped page factory and LRU cache. Whenever big array needs a mapped page, it requests one from the mapped page factory and returns it to the factory when it has done with the page. Mapped page factory encapsulates algorithm to allocate, cache and recycle mapped pages in a memory efficient and thread safe way by leveraging LUR cache structure.</p>

<p>Now, with the design in mind, I can implement these abstract structures in a bottom up, layer by layer approach, you can find the implementation details by studying the open source java code on <a href="https://github.com/bulldog2011/bigqueue">github</a> if you are interested.</p>

<h1>Additional Design Notes:</h1>

<ul>
<li><p>Although I learned some people used to map a single big file into memory, like <a href="http://kdgcommons.svn.sourceforge.net/viewvc/kdgcommons/trunk/src/main/java/net/sf/kdgcommons/buffer/MappedFileBuffer.java?revision=HEAD&amp;view=markup">here</a> and <a href="http://vanillajava.blogspot.com/2011/12/using-memory-mapped-file-for-huge.html">here</a>, I have memory leak concern with such approach(though I am not sure), instead, I came with up a novel pagging and swapping algorithm which only map fixed size(for example, 128M) page file into memory on demand and unmap it when it is not accessed within a fixed time to live(TTL) period. Which such design, I can not only use memory safer and more efficient, but can delete some used pages files to save disk space whenever necessary.</p></li>
<li><p>As we know, queue is a rear append and front read structure, so as long as the queue front page and rear page(technically, this is called working set) are in memory, read and append operations can always happen in memory, that means the enqueue and dequeue operations are always close to O(1) memory access.</p></li>
<li><p>The big queue is based on a <strong>big array</strong> structure, the big array itself is an interesting data structure with some unique features(I plan to write some use cases of this structure in the near future), the big array supports sequential append(called append only array), sequential and random read. Sequential append and read are both O(1) memory access, while random read is O(1) memory access if the corresponding page is in cache, and is O(1) disk access if the corresponding page is not in cache. The big array is index based, just like normal indexed array, starting with index 0, when a new item is appended, the head index will be incremented, index is the pointer to the appended data, later you can use the index to read back the data. The index is of type long, this is a really very big range, I guess the big array won’t be used up before the world is end:).</p></li>
<li><p>Internally, two logical files(phycially one logical file consists of many fixed size page files) are used by one big array, one is index file, the other is data file, when data is read by index, the index will be first mapped to an index page file, then into an item in the index page file, the index item has pointer and length information to the actual data in data file, data can be retrieved by just inspecting index item, load corresponding data page file and read data in it. New data can be appended just by finding out next to be appended data page file and offset, then put the data and update corresponding index item.</p></li>
<li><p>Serialization is outside of the consideration of the big queue framework, the enqueue operation only accepts byte array as input(the dequeue operation only returns byte array), I left out serialization deliberately since I think it should not be the responsibility of the big queue framework, there are many existing and well known serialization frameworks(like protobuf, thrift, etc) which can do serialization work better.</p></li>
<li><p>To ensure thread safe, some multi-threading technologies like read-write lock and thread local buffer are leveraged, the queue can work in read/write separation way – consumer and producer can work concurrently, this tremendously improved the throughput of the queue.</p></li>
<li><p>The queue has interface to delete used page files(for example, if data in these page files have been consumed by consumers) to save disk space, this is called garbage collection on disk files, much like GC in memory.</p></li>
<li><p>Abstractly, the whole queue looks like a huge FIFO circle buffer, disk backed and memory mapped.</p></li>
</ul>


<h1>Performance Test</h1>

<p>Below is the preformance test conclusion:</p>

<ul>
<li>In concurrent producing and consuming case, the average throughput is around <strong><em>166MBps</em></strong>.</li>
<li>In sequential producing then consuming case, the average throughput is around <strong><em>333MBps</em></strong>.</li>
</ul>


<p>Suppose the average message size is 1KB, then big queue can concurrently producing and consuming<br/>
166K message per second on a commodity machine under normal load. Basically, the throughput is only limited by disk IO bandwidth.</p>

<p>The detailed performance test report is <a href="https://github.com/bulldog2011/bigqueue/wiki/Performance-Test-Report">here</a>, the corresponding test program is <a href="https://github.com/bulldog2011/bigqueue/blob/master/src/test/java/com/leansoft/bigqueue/perf/BigQueuePerfTest.java">here</a>, and the full hardware spec for benchmark is <a href="http://bulldog2011.github.com/lab/">here</a>.</p>

<h1>Conclusion</h1>

<p>To resolve a big data challenge I designed and implemented a simple while elegant big queue that is:</p>

<blockquote><ol>
<li><strong>Fast</strong> : close to the speed of direct memory access, both enqueue and dequeue are close to O(1) memory access.</li>
<li><strong>Big</strong> : the total size of the queue data is only limited by the available disk space.</li>
<li><strong>Persistent</strong> : all data in the queue is persisted on disk, and is crash resistant.</li>
<li><strong>Memory-efficient</strong> : automatic paging &amp; swapping algorithm, only most-recently accessed data is kept in memory.</li>
<li><strong>Thread-safe</strong>: multiple threads can concurrently enqueue and dequeue without data corruption.</li>
<li><strong>Simple and Light-weight</strong>: current number of source files is 12 and the library jar is less than 20K.</li>
</ol>
</blockquote>

<p>Log data collecting is just use case of the big queue, I can anticipate the big queue will be used in more scenarios since big data challenges are becoming common these days.</p>
]]></content>
  </entry>
  
</feed>
