<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nano | Abstraction Builder]]></title>
  <link href="http://bulldog2011.github.com/blog/categories/nano/atom.xml" rel="self"/>
  <link href="http://bulldog2011.github.com/"/>
  <updated>2013-02-18T13:16:38+08:00</updated>
  <id>http://bulldog2011.github.com/</id>
  <author>
    <name><![CDATA[Bulldog]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Schema Driven Web API Client Development on Android, Part 1: Hello eBay Finding]]></title>
    <link href="http://bulldog2011.github.com/blog/2013/02/17/schema-driven-on-android-part-1-hello-ebay-finding/"/>
    <updated>2013-02-17T12:48:00+08:00</updated>
    <id>http://bulldog2011.github.com/blog/2013/02/17/schema-driven-on-android-part-1-hello-ebay-finding</id>
    <content type="html"><![CDATA[<p>Scheam driven web service development is quite popular in Java world, JAXB and JAX-WS are both mature standard, and frameworks like CXF, Axis are famous amount many developers for fast service development. It's common to do scheam driven developent on server side, can scheam driven client development be done on Android? Yes, you can. Today I will show you how do do scheam driven development on Android by leveraging following light-weight frameworks:</p>

<!--more-->


<blockquote><ol>
<li><a href="https://github.com/bulldog2011/nano-rest">Nano-rest</a> restful client framework for Android, with Nano xml binding support.</li>
<li><a href="https://github.com/bulldog2011/mxjc">mxjc</a> scheam to Android java binding compiler.</li>
</ol>
</blockquote>

<p>The serivce I choose for demo is <a href="https://www.x.com/developers/ebay/products/finding-api">eBay Finding service</a>, here are why I choose this service:</p>

<blockquote><ol>
<li>I have some direct experience with this service.</li>
<li>eBay Finding serivce supports schema driven development since it provides a wsdl, at the same time, it also supports RESTful style service call.</li>
</ol>
</blockquote>

<p>If you are not familar with this serivce, please visit its <a href="https://www.x.com/developers/ebay/products/finding-api">official site</a>.</p>

<h3>The Big Picture</h3>

<p>TODO</p>

<h3>Step 1 : Generate service classes from schema</h3>

<p>The first step of scheam driven development is to generate service classes from schema or wsdl, let's download eBay Finding serivce wsdl <a href="http://developer.ebay.com/webservices/finding/latest/FindingService.wsdl">here</a>, also, let's download <a href="https://github.com/bulldog2011/mxjc">mxjc binding compiler</a> zip package by following links on the github site, extract the zip package, suppose we put the wsdl in the same folder as the extracted zip package, then we execute command(suppose we are in Windows environment, Unix environment will be similar).</p>

<p><code>
bin\mxjc.bat -wsdl FindingService.wsdl
</code></p>

<p>When we execute this command, the schema inside the wsdl will be parsed by the binding compiler and Nano bindable classes will be generated, by default, the binding compiler will derive package name from wsdl, but you can override this by providing custom package name directly as command line options.
'-wsdl' option is needed since we are generating from wsdl, not default xsd. <br/>
By default, the service classes will be generated in the current directory.</p>

<h3>Step 2: Create a New Android Project</h3>

<p>Now let's create a new Android project in IDE like Eclipse with ADT installed, to use Nano-rest client framework, the Android API version must be equal to or newer than 7(Androdi 2.1 or above), this is required since Nano-rest leverages Android Service mechanism for asynchronous service invocation.</p>

<p>With new Android project created, let's add Nano-rest jar in the <strong><em>libs</em></strong> folder of the project, the Nano-rest jar can be downloaded by following link on the <a href="https://github.com/bulldog2011/nano-rest">Nano-rest github site</a>, the shaded jar is preferred since it already includes Nano xml binding framework dependency, otherwise, you have to add Nano xml binding framework jar separately.
Now, let's copy the above generated service classes into the <strong><em>src</em></strong> folder the project, if we refresh the project, there should be no compiling error since all imports in the generated classes can be resolved by the Nano-rest shaded jar reference.</p>

<p>To let Nano-rest framework work correctly at runtime, we <strong><em>must</em></strong> added following declarations in the manifest file of the project:</p>

<p>```xml</p>

<p>  <uses-permission android:name="android.permission.INTERNET" /></p>

<p>  <uses-sdk android:minSdkVersion="7" /></p>

<p>  <application></p>

<pre><code>&lt;service android:name="com.leansoft.nanorest.service.HTTPRequestExecutorService" &gt;
&lt;/service&gt;
</code></pre>

<p>  </application></p>

<p>```</p>

<p>The uses-permission declaration is needed for internet access, the minSdkVersion declaration has be explained above, and the HTTPRequestExecutorService class is required for asynchronous service invocation, synchronous service invocation may block Android main UI, leading to process crash, this is not expected, so as a best practice, we should always invoke service asynchronously on Android.</p>

<h3>Step 3 : Create eBay Finding API Proxy</h3>

<p>Web service client proxy can simplify service invocation code, usually, web serivce framework like CXF or JAX-WS has tool to auto-generate service proxy from wsdl, however, current mxjc binding compiler does not support proxy generation yet(it can only generate service classes from schema), but it's not hard for us to write proxy class manually since Nano-rest has already encapsulated generic service invocation logic for us, we only need to extend it and add a few service specific logic, let's just do it:</p>

<p>First, let's definite some constants which will be used later:</p>

<p>``` java</p>

<p>package com.ebay.finding;</p>

<p>public interface FindingConstants {</p>

<pre><code>public static String PRODUCTION_ENDPOINT = "http://svcs.ebay.com/services/search/FindingService/v1";

public static String SANDBOX_ENDPOINT = "http://svcs.sandbox.ebay.com/services/search/FindingService/v1";

public static String X_EBAY_SOA_OPERATION_NAME = "X-EBAY-SOA-OPERATION-NAME";

public static String X_EBAY_SOA_SECURITY_APPNAME = "X-EBAY-SOA-SECURITY-APPNAME";
</code></pre>

<p>}</p>

<p>```
These constants are quite self explanatory, so I won't give more comments.</p>

<p>Then we build a simple authentication class, eBay Finding serivce need a <strong><em>APP NAME</em></strong> as one of http request headers, so we just add it,</p>

<p>``` java</p>

<p>package com.ebay.finding.auth;</p>

<p>import com.ebay.finding.FindingConstants;
import com.leansoft.nanorest.auth.AuthenticationProvider;
import com.leansoft.nanorest.client.BaseRestClient;</p>

<p>public class AppNameAuthenticationProvider implements AuthenticationProvider {</p>

<pre><code>@Override
public void authenticateRequest(BaseRestClient client) {
    client.addHeader(FindingConstants.X_EBAY_SOA_SECURITY_APPNAME, "YOUR_APPNAME_HERE");
}
</code></pre>

<p>}</p>

<p>```</p>

<p><strong><em>Note</em></strong>, before you can run the final finished application, you mush replace the APP NAME placeholder with your own eBay developer APP NAME which can be applied on eBay developer site.</p>

<p>Next, let's build a generic request processor for eBay Finding serivce, with this base request processor, all specific request processors(supported by eBay Finding service) can be easily built later, let's see the full definition of this base request processor:</p>

<p>``` java</p>

<p>package com.ebay.finding.request;</p>

<p>import com.ebay.finding.FindingConstants;
import com.ebay.finding.auth.AppNameAuthenticationProvider;
import com.ebay.marketplace.search.v1.services.AckValue;
import com.ebay.marketplace.search.v1.services.BaseServiceResponse;
import com.ebay.marketplace.search.v1.services.ErrorMessage;
import com.leansoft.nanorest.callback.HttpCallback;
import com.leansoft.nanorest.client.RestClient;
import com.leansoft.nanorest.domain.ResponseStatus;
import com.leansoft.nanorest.logger.ALog;
import com.leansoft.nanorest.parser.NanoXmlResponseParser;
import com.leansoft.nanorest.request.NanoXmlRequestProcessor;</p>

<p>public class BaseFindingRequestProcessor<T> extends NanoXmlRequestProcessor<T> {</p>

<pre><code>private final Class&lt;T&gt; responseType;

public BaseFindingRequestProcessor(Object requestObject, String opName, Class&lt;T&gt; responseType, 
        HttpCallback&lt;T&gt; callback) {

    super(requestObject,
          responseType,
          callback);

    this.responseType = responseType;


    RestClient client = getRestClient();
    client.setUrl(FindingConstants.PRODUCTION_ENDPOINT);
    client.setAuthentication(new AppNameAuthenticationProvider());

    client.addHeader(FindingConstants.X_EBAY_SOA_OPERATION_NAME,  opName);
}

private NanoXmlResponseParser&lt;ErrorMessage&gt; errorMessageParser = 
        new NanoXmlResponseParser&lt;ErrorMessage&gt;(ErrorMessage.class);

@Override
protected void handleResponse() {

    final RestClient client = getRestClient();
    final ResponseStatus status = client.getResponseStatus();
    String response = client.getResponse();
    ALog.d(TAG, status.toString());
    if (status.getStatusCode() &lt; 200 || status.getStatusCode() &gt;= 300) {
        if (isXmlResponse(response)) {
            parseErrorMessage(response);
        } else {
            getResponseHandler().handleError(status);
        }
    } else {
        parseHttpResponse(response);
    }

}

private void parseErrorMessage(String response) {
    try {
        final ErrorMessage errorMessage = errorMessageParser.parse(response);

        T responeData = responseType.newInstance();
        BaseServiceResponse baseServiceResponse = (BaseServiceResponse)responeData;
        baseServiceResponse.setAck(AckValue.FAILURE);
        baseServiceResponse.setErrorMessage(errorMessage);

        getResponseHandler().handleSuccess(responeData);
    } catch (final Exception e) {
        ResponseStatus responseStatus = ResponseStatus.getParseErrorStatus();
        ALog.d(TAG, responseStatus.toString(), e);
        getResponseHandler().handleError(responseStatus);
    }
}

private boolean isXmlResponse(String response) {
    if (response == null) return false;
    return response.startsWith("&lt;?xml");
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Base request processor is the core of the proxy, let me give more comments about the base processor:<br/>
1. we extend NanoXmlRequestProcessor class, since we want to leverage Nano xml framework for request marshalling and response unmarshalling.<br/>
2. In the constuctor, we provides request object, operaion name and
a HttpCallback instance as parameters and delegate these parameters to the super class, the requst object is an eBay Finding request object like FindItemsByKeywordsRequest object, the operation name is required by eBay Finding service as request header, and I will give more explanation about the HttpCallback instance later. <br/>
3. Also in the constructor, we set eBay Finding service production endpoint url on the rest client(replace here if you need to access sandbox instead), plug in authentication provider defined above, and add operation name as request header. Note, authentication provider plugin is not necessary, you can always add APP NAME directly on the rest client as a request header, I use authentication provider here just to show the formal way to do authentication when Nano-rest framework is used.<br/>
4. The response handling logic of the eBay Finding serivce needs a special fix, usually, eBay service supports RRE(resposne resident error), means error message are wrapped in a normal response message, but in some cases, eBay Finding service may return a single error xml message without a wrapping response. In order to fix this, I overrided the Nano-rest response handling logic, please see handleResponse and
parseErrorMessage methods for details.</p>

<p>The responseHandler(defined in super class and returned by getResponseHandler method) is assocated with the HttpCallback instance passed in the constructor, it only has two methods: handleSuccess and handleError, usually, if the service invocation is successful, then handleSuccess method should be called, otherwise, handleError method should be called, responseHandler is only responsilbe for the callback, concrete success or error handling logic is defined by application logic.</p>

<p>With base processor defined, it's quite easy to define a specific request processor, let's define a FindItemsByKeywordsReqeustProcessor since I will use this function of eBay Finding service as demo:</p>

<p>``` java
package com.ebay.finding;</p>

<p>import com.ebay.finding.request.BaseFindingRequestProcessor;
import com.ebay.marketplace.search.v1.services.FindItemsByKeywordsRequest;
import com.ebay.marketplace.search.v1.services.FindItemsByKeywordsResponse;
import com.leansoft.nanorest.RequestProcessor;
import com.leansoft.nanorest.callback.HttpCallback;</p>

<p>public class FindingService {</p>

<pre><code>public static final String TAG = FindingService.class.getSimpleName();

public static RequestProcessor getFindItemsByKeywordsRequestProcessor( 
        FindItemsByKeywordsRequest requestObject, 
        HttpCallback&lt;FindItemsByKeywordsResponse&gt; callback) {
    return new BaseFindingRequestProcessor&lt;FindItemsByKeywordsResponse&gt;(requestObject, "findItemsByKeywords", FindItemsByKeywordsResponse.class, callback);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Not much code, and no magic here if you are familar with Java generic. We just define a factory method, provide specific parameters requried by FindItemsByKeywords API call. Use this method as template, it's not hard for you to create other request processors, like <br/>
getFindItemsAdvandedRequestProcessor, getFindItemsByCategoryRequestProcessor, etc, all functions of eBay Finding service can be defined in this way, actually, you can even build a complete eBay Finding SDK in this way for later reuse.</p>

<h3>Step 4: Write real application logic and UI</h3>

<p>Now it's time for us to write real application logic and UI, in this demo, I just want to show minimum application logic and UI, the UI part only has an EditText as keywords input and a Button to trigger search by calling FindingItemsByKeywords API, and a Toast for response display.
The application logic is even simpler, let's see the whole definition of the Main Activity:</p>

<p>``` java
package com.leansoft.nanorest.sample;</p>

<p>import com.ebay.finding.FindingService;
import com.ebay.marketplace.search.v1.services.AckValue;
import com.ebay.marketplace.search.v1.services.FindItemsByKeywordsRequest;
import com.ebay.marketplace.search.v1.services.FindItemsByKeywordsResponse;
import com.ebay.marketplace.search.v1.services.PaginationInput;
import com.leansoft.nanorest.RequestProcessor;
import com.leansoft.nanorest.callback.HttpCallback;
import com.leansoft.nanorest.domain.ResponseStatus;</p>

<p>import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Toast;
import android.widget.EditText;
import android.app.Activity;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>private Button btn;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    btn = (Button) this.findViewById(R.id.btn);
    btn.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            String keywords = ((EditText) findViewById(R.id.edit_input)).getText().toString();  
            FindItemsByKeywordsRequest request = new FindItemsByKeywordsRequest();
            request.setKeywords(keywords);
            PaginationInput pi = new PaginationInput();
            pi.setPageNumber(1);
            pi.setEntriesPerPage(1);
            request.setPaginationInput(pi);

            RequestProcessor requestProcessor = FindingService.getFindItemsByKeywordsHttpRequest(
                    request, 
                    new FindItemsByKeywordsCallback()
                    );
            requestProcessor.invokeAsync(MainActivity.this.getApplicationContext());
        }

    });
}

private final class FindItemsByKeywordsCallback implements HttpCallback&lt;FindItemsByKeywordsResponse&gt; {

    @Override
    public void onSuccess(FindItemsByKeywordsResponse responseData) {

        if (responseData.getAck() == AckValue.SUCCESS) {
            Toast.makeText(getApplicationContext(),
                    responseData.getSearchResult().getItem().get(0).getTitle(),
                    Toast.LENGTH_LONG).show();
        } else {
            Toast.makeText(getApplicationContext(),
                    responseData.getErrorMessage().getError().get(0).getMessage(),
                    Toast.LENGTH_LONG).show();
        }
    }

    @Override
    public void onHttpError(ResponseStatus responseCode) {
        Toast.makeText(getApplicationContext(),
                responseCode.getStatusCode() + " " + responseCode.getStatusMessage(),
                Toast.LENGTH_LONG).show();

    }

}
</code></pre>

<p>}</p>

<p>```</p>

<p>The code is easy to understand if you know Java and Android, let me give a few comments:<br/>
1. We register a click listener to the button, inside the listener is the main application logic:
get keywords input and build a FindItemByKeywordsRequest object, get a FindItemByKeywordsRequestProcessor from the factory we defined above, and invoke the request processor asynchronously at last.<br/>
2. When we build the FindItemByKeywordsRequestProcessor instance, we passed in a FindItemsByKeywordsCallback instance as parameter, FindItemsByKeywordsCallback implements HttpCallback interface, it contains the main response logic, this is the place when final asynchronous response handling happen. Usually, inside a HttpCallback, we update UI according to the success or failure of the response, in this case, if the response is successful, we show the title of the result item, if there is http error, we show the status code and message. Since eBay Finding service support Response Resident Error(RRE), even in the onSuccess callback, we still need to check the Ack value to find out if there is application error and handle accordingly.</p>

<p>Here I just show a typical asynchronous service invocation paradigm using Nano-rest framework, you can follow this paradigm for other service invocations according to your real needs.</p>

<h3>Step 5 : Run the application</h3>

<p>Now lets run the application, note again, please fill in your APP NAME before you run the application, below is the UI of a success case:</p>

<p><img class="center" src="/images/nano-rest/hello_ebay_finding_success.png" width="400" height="600"></p>

<p>Let's provide an invalid APP NAME and try again, below is the UI of the failed case since the APP NAME is invalid:</p>

<p><img class="center" src="/images/nano-rest/hello_ebay_finding_failure.png" width="400" height="600"></p>

<p>To facilitate debug and trouble shooting, you can always check the request or response xml by looking at the log in the LogCat provided by ADT.</p>

<h3>Conclusion:</h3>

<p>The demo shown in this tutorial is just a bare minimum or starter kit, there is still much work to do before you can release a fully functional service backed Android application, but anyway, with a reuseable service proxy, you are free from low level and error-prone serivce message parsing and http handling anymore, instead, you can put your effor on main application logic and UI, this can definitly accelerate the development of the application.</p>

<p>Scheam driven development is a popular and mature development methodology, when used appropriately, it can improve development efficiency and enhance the reliability and maintainability of the application. Now with the support of Nano-rest framework and the mxjc binding compiler, we can also do schema driven client development on Android.</p>

<p>You can find the whole source of the sample application and all the generated eBay Finding service classes <a href="https://github.com/bulldog2011/nano-rest/tree/master/sample/HelloEBayFinding">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[movie search android app using nano]]></title>
    <link href="http://bulldog2011.github.com/blog/2013/02/12/movie-search-android-app-using-nano/"/>
    <updated>2013-02-12T17:02:00+08:00</updated>
    <id>http://bulldog2011.github.com/blog/2013/02/12/movie-search-android-app-using-nano</id>
    <content type="html"><![CDATA[<p><a href="http://www.javacodegeeks.com/author/Ilias-Tsagklis">Some one</a> did a great job to write a tutorial about <a href="http://www.javacodegeeks.com/2010/10/android-full-application-tutorial.html">the development of an end to end Android application</a>,  this is a full android application, including main activity UI, HTTP interaction, async request handling and response parsing, list view, etc. In that tutorial, the author manually parsed the response to domain objects using SAX parser built in Android, while in this post, I will show you how I adapted that application by leveraging automatic annotation driven binding supported by Nano xml binding framework.</p>

<!--more-->


<p><a href="https://github.com/bulldog2011/nano">Nano</a> is a light-weight xml binding framework tailored for Android platform, with Nano, you can be free from error-prone and tedious xml parsing work, instead, you can focus your main development effort on application logic and UI.</p>

<p>The original author has elaborated the development steps of the application in his tutorial series, so in this post, I will not repeat what he has done very well, please refer to his tutorial for details about the overall application development. In this post, I will focus on the adaption of the response binding with domain objects part, using Nano binding framework.</p>

<p>The application is a typical movie search application, using <a href="http://api.themoviedb.org/2.1/">TMDb API</a> in the backend, if you are not familar with this API, please have a quick review of its official site, also, If you want to try the sample appliction on emulator or real Android device, you need to <a href="https://www.themoviedb.org/account/signup">sign up</a> for a TMDb account, get the API key, and replace the API key placeholder with your real key before you run the application, the source file need to be changed is <a href="https://github.com/bulldog2011/nano/blob/master/sample/AndroidMovieSearchAppProject/src/com/javacodegeeks/android/apps/moviesearchapp/services/GenericSeeker.java">this one</a>.</p>

<p>Let's cut to the chase and see how to perform the binding. The main API we will use is <a href="http://api.themoviedb.org/2.1/methods/Movie.search">movie search</a>, you can find an example response on the API usage page.</p>

<p>First of all, download latest Nano release by following link on <a href="https://github.com/bulldog2011/nano">this page</a>, and put the Nano jar in the <strong><em>libs</em></strong> folder of the sample application(You can download the original application <a href="http://dl.dropbox.com/u/7215751/JavaCodeGeeks/AndroidFullAppTutorialPart07/AndroidMovieSearchAppProject_Part07.zip">here</a>, or you may download the whole adapted application by following link at the end of this post).</p>

<p>The most important thing is to create the model objects and map appropriately to the XML document by inspecting the sample response on TMDb API site. If we take a look at the XML file, we should see that the root element is called OpenSearchDescription and it includes a Query element, a "totalResults" element and a number of movies. Here is our main model class looks like:</p>

<p>``` java</p>

<p>package com.javacodegeeks.android.apps.moviesearchapp.model;</p>

<p>import java.io.Serializable;</p>

<p>import com.leansoft.nano.annotation.Element;
import com.leansoft.nano.annotation.RootElement;</p>

<p>@RootElement(name="OpenSearchDescription")
public class MovieSearchResult implements Serializable {</p>

<pre><code>private static final long serialVersionUID = -5992078345571261309L;

@Element(name="Query")
public Query query;

@Element
public int totalResults;

@Element(name="movies")
public MovieContainer movieContainer;
</code></pre>

<p>}</p>

<p>```</p>

<p>The <a href="http://bulldog2011.github.com/nano/apidocs/com/leansoft/nano/annotation/RootElement.html">RootElement</a> annotation denotes that the specific class represents a root XML element, we also provided a <a href="http://bulldog2011.github.com/nano/apidocs/com/leansoft/nano/annotation/RootElement.html#name%28%29">name</a> parameter equals to 'OpenSearchDescription' in the annotation since this is the real root element name in the sample response, if this name is not provided, Nano will by default use the class name(with first chararacter in lower case) as the element name, this is not expected. We also use the <a href="http://bulldog2011.github.com/nano/apidocs/com/leansoft/nano/annotation/Element.html">Element</a> annotations for the nested elements. Note that Nano can only handle annotations annotated directly on fields, not on get/set methods, it's ok to annotate either public or private fields. One thing to be aware of is that we use the <a href="http://bulldog2011.github.com/nano/apidocs/com/leansoft/nano/annotation/Element.html#name%28%29">name</a> parameter(for "Query" and "movies") in order to explicitly specify the corresponding XML element name. This should be done when the XML element has a different name than the Java field, since Nano by default looks for an element with the same name as the field.</p>

<p>Let's now see the Query class:</p>

<p>``` java</p>

<p>package com.javacodegeeks.android.apps.moviesearchapp.model;</p>

<p>import java.io.Serializable;</p>

<p>import com.leansoft.nano.annotation.Attribute;</p>

<p>public class Query implements Serializable {</p>

<pre><code>private static final long serialVersionUID = 7875169023013805580L;

@Attribute
public String searchTerms;
</code></pre>

<p>}</p>

<p>```
This class contains only an attribute called "sarchTerms", so the relevant field is annotated with <a href="http://bulldog2011.github.com/nano/apidocs/com/leansoft/nano/annotation/Attribute.html">Attribute</a>.</p>

<p>Very easy until now. Let's check the more complex Movie class:</p>

<p>``` java</p>

<p>package com.javacodegeeks.android.apps.moviesearchapp.model;</p>

<p>import java.io.Serializable;</p>

<p>import com.leansoft.nano.annotation.Default;
import com.leansoft.nano.annotation.Element;</p>

<p>@Default
public class Movie implements Serializable {</p>

<pre><code>private static final long serialVersionUID = 5114870955079482108L;

public String score;
public String popularity;
public boolean translated;
public boolean adult;
public String language;
@Element(name="original_name")
public String originalName;
public String name;
public String type;
public String id;
@Element(name="imdb_id")
public String imdbId;
public String url;
public String votes;
public String rating;
public String certification;
public String overview;
public String released;
public String version;
@Element(name="last_modified_at")
public String lastModifiedAt;

@Element(name="images")
public ImageContainer imageContainer;
</code></pre>

<p>}</p>

<p>```
This class contains many fields, all of them map to XML element, we don't want get trouble with writing Element annotations on every fields, so we just add a <a href="http://bulldog2011.github.com/nano/apidocs/com/leansoft/nano/annotation/Default.html">Default</a> annotation at the class level, indicating that fields of this class should be mapped to default XML element unless explicitly specified. We also need to explicitly provide annotation parameter name on some fields(like original_name, imdb_id, last_modified_at and images) since there is a mismatch between Java field name and corresponding XML element name.</p>

<p>Let's see the Image class:</p>

<p>``` java</p>

<p>package com.javacodegeeks.android.apps.moviesearchapp.model;</p>

<p>import java.io.Serializable;</p>

<p>import com.leansoft.nano.annotation.Attribute;</p>

<p>public class Image implements Serializable {</p>

<pre><code>private static final long serialVersionUID = -5274909668022888191L;

public static final String SIZE_ORIGINAL = "original";
public static final String SIZE_MID = "mid";
public static final String SIZE_COVER = "cover";
public static final String SIZE_THUMB = "thumb";

public static final String TYPE_PROFILE = "profile";
public static final String TYPE_POSTER = "poster";

@Attribute
public String type;

@Attribute
public String url;

@Attribute
public String size;

@Attribute
public int width;

@Attribute
public int height;

@Attribute
public String id;
</code></pre>

<p>}</p>

<p>```
This class includes only attributes so we annotate the fields accordingly, there is no annotation on public static final fields, so these fields are not visable to Nano binding framework at runtime.</p>

<p>Till now, the carefull reader will find that the root MovieSearchResult class has no direct reference to the Movie class(The Movie class also has no direct reference to the Image class), the MovieSearchResult class only reference a container class called MovieContainer, why we need a container class instead of a direct Movie class reference? This is caused by a limitation of current Nano framework, it does not support <strong><em>inline style list</em></strong> yet. By inspecting the sample XML response, you will find a list of movie elements are wrapped in a movies element, but there is no specific annotation for wrapper element, so as a workaround, we build a container class for the wrapper element, below is the definition of the MovieContainer(ImageContainer is similar):</p>

<p>``` java</p>

<p>package com.javacodegeeks.android.apps.moviesearchapp.model;</p>

<p>import java.io.Serializable;
import java.util.List;</p>

<p>import com.leansoft.nano.annotation.Element;</p>

<p>public class MovieContainer implements Serializable {</p>

<pre><code>private static final long serialVersionUID = -957664961371798735L;

@Element(name="movie")
public List&lt;Movie&gt; movies;
</code></pre>

<p>}</p>

<p>```</p>

<p>With all domain class mapping defined, the final step is to write the response binding code, this is quite simple since the original author designed the application in a quite clean way, just find the GenericSeeker abstract class in the services package, in the class we define and initialize a Nano xml reader, see below(most irrelevant content of this class is omitted here to save space):</p>

<p>``` java</p>

<p>package com.javacodegeeks.android.apps.moviesearchapp.services;</p>

<p>import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.List;</p>

<p>import com.leansoft.nano.IReader;
import com.leansoft.nano.NanoFactory;</p>

<p>public abstract class GenericSeeker<E> {</p>

<pre><code>protected IReader xmlReader = NanoFactory.getXMLReader();
</code></pre>

<p>}</p>

<p>```</p>

<p>Then in the concrete MovieSeeker class we bind the HTTP response with MovieSearchResult class instance in Nano way, the binding can't be simpler, it's only one java statement, below is an extract of the MovieSeeker class:</p>

<p>``` java</p>

<p>package com.javacodegeeks.android.apps.moviesearchapp.services;</p>

<p>import java.util.List;</p>

<p>import android.util.Log;</p>

<p>import com.javacodegeeks.android.apps.moviesearchapp.model.Movie;
import com.javacodegeeks.android.apps.moviesearchapp.model.MovieSearchResult;</p>

<p>public class MovieSeeker extends GenericSeeker<Movie> {</p>

<pre><code>private List&lt;Movie&gt; retrieveMoviesList(String query) throws Exception {
    String url = constructSearchUrl(query);
    String response = httpRetriever.retrieve(url);
    Log.d(getClass().getSimpleName(), response);
    MovieSearchResult searchResult = xmlReader.read(MovieSearchResult.class, response);
    if (searchResult.movieContainer != null) {
        return searchResult.movieContainer.movies;
    } else {
        return null;
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>That's all I have done to adapt the orignal application to use Nano binding instead, now let's run the sample in emulator(don't forget to fill in your API key before run), below is a screenshot:</p>

<p><img class="center" src="/images/nano/movie_search.png" width="400" height="600"></p>

<p>Cool! with automatic annotation driven binding supported by Nano, there is no error-prone and tedious manual xml parsing anymore, the whole application becomes even more cleaner and maintainable. So, when you develop your next xml service based Android application, remember that manual xml parsing is not necessary on Android platform, it can be completely automated by Nano binding framework!</p>

<p>You may get the whole source of the adapted application <a href="https://github.com/bulldog2011/nano/tree/master/sample/AndroidMovieSearchAppProject">here</a>.</p>

<p>At last, I would thank the original author again for a great tutorial he has written!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nano on android tutorial 1]]></title>
    <link href="http://bulldog2011.github.com/blog/2013/02/10/nano-on-android-tutorial-1/"/>
    <updated>2013-02-10T16:09:00+08:00</updated>
    <id>http://bulldog2011.github.com/blog/2013/02/10/nano-on-android-tutorial-1</id>
    <content type="html"><![CDATA[<p>This is my first post showing how to use Nano on Android, in this post, I will show you how to use Nano to export and import a set of domain object as XML to/from the SD card on Android. Nano is tailored for Android platform, you will see in this post how Nano can greatly simplify tedious and boring object and xml binding task in Android application development.</p>

<!--more-->


<h3>Prerequisite</h3>

<p>Nano is quite light, On Android platform, it has no 3rd party jar dependency, all you need to do is to create a noraml Android project and add reference to the Nano jar, you can find latest Nano jar by following link <a href="https://github.com/bulldog2011/nano">here</a>, by the way, if necessary, you may also reference Nano source directly in your project.</p>

<h3>Define Domain Classes</h3>

<p>As usual project, let's define domain classes first. The set of domain classes is small but illustrates how to serialize both aggregations and lists of other domain classes. At the root is an Organization class, that has a name, Address object and a list of Person objects. Each Person object has a name and an Address object. Below are the definitions of these domain classses, note, get/set methods are omitted to save space.</p>

<h4>Organization</h4>

<p>``` java</p>

<p>package com.leansoft.nano.sample.domain;</p>

<p>import java.util.ArrayList;
import java.util.List;</p>

<p>import com.leansoft.nano.annotation.Attribute;
import com.leansoft.nano.annotation.Default;</p>

<p>@Default
public class Organization {</p>

<pre><code>private String name;

private Address address = new Address();

private List&lt;Person&gt; staff = new ArrayList&lt;Person&gt;();

@Attribute
private int count;
</code></pre>

<p>}</p>

<p>```</p>

<h4>Address</h4>

<p>``` java</p>

<p>package com.leansoft.nano.sample.domain;</p>

<p>import com.leansoft.nano.annotation.Default;</p>

<p>@Default
public class Address {</p>

<pre><code>private String street;
private String code;
private String city;
</code></pre>

<p>}</p>

<p>```</p>

<h4>Person</h4>

<p>``` java</p>

<p>package com.leansoft.nano.sample.domain;</p>

<p>import com.leansoft.nano.annotation.Default;</p>

<p>@Default
public class Person {</p>

<pre><code>private String name;
private Address address = new Address();
</code></pre>

<p>}</p>

<p>```</p>

<p>Note, all domain classes are annotated with @Default Nano annotation, indicating that all fields of the class will be mapped to xml element during serialization, except that on the count filed of Organization, there is an explicit @Attribute annotation, indicating that the count field will be mapped to xml attribute during serialization.</p>

<p>Also, I've build a Generator class to auto-generate faked organization with faked person list, to save space, I don't  want to dump the Generator code here, you can find the source <a href="https://github.com/bulldog2011/nano/blob/master/sample/nano-and-android/src/com/leansoft/nano/sample/domain/Generator.java">here</a>.</p>

<h3>The Sample Flow</h3>

<p>The sample has a quite simple flow :  <br/>
1. On applicaton startup, auto-generate a faked organization with a random number of persons.<br/>
2. On click the 'Export Data' button, serialize the organization to xml on SD card using Nano Xml writer, then update status text with bytes written.<br/>
3. On click the 'Import Data' button, deserialize the xml on SD card into organization object using Nano Xml reader, then update status text with person size got.</p>

<p><img class="center" src="/images/nano/nano_and_android.png" width="400" height="600"></p>

<p>The main UI of the sample cantains three components:<br/>
1. A 'Export Data' button for serialization demo. <br/>
2. A 'Import Data' button for deserialization demo.<br/>
3. A TextView for status display.</p>

<p><strong><em>Note</em></strong>, faked data generation, export, import may be time consuming tasks depending the size of the data, executing these time consuming tasks directly on main UI thread may block it, leading to application crash, so it's a best practice to encapsulate these tasks as asyn tasks, and to use progress bar to let user know the progress of the task. I have encapsulated these tasks using Android AsyncTask structure, for details, please refer to the source of this demo project(link at the end of this post), for more background about Android AsyncTask, please refer to <a href="http://developer.android.com/reference/android/os/AsyncTask.html">its documentation</a>.</p>

<p>The buttons <strong><em>Export</em></strong> and <strong><em>Import</em></strong> have their click actions tied to the flowing methods:</p>

<p>``` java</p>

<p>Button exportButton = (Button)findViewById(R.id.exportButton);
exportButton.setOnClickListener( new OnClickListener() {</p>

<pre><code>@Override
public void onClick(View arg0) {

    ExportTask  task = new ExportTask(MainActivity.this, new OnCompletionListener() {
        public void onCompletion(Object result) {
            File file = (File) result;
            appendStatus(String.format("Written %d bytes to %s", file.length(), file.getAbsolutePath()));
        }
    });
    task.execute(organization, dirName, fileName);

}
</code></pre>

<p>});</p>

<p>```</p>

<p>``` java</p>

<p>Button importButton = (Button)findViewById(R.id.importButton);
importButton.setOnClickListener(new OnClickListener() {</p>

<pre><code>@Override
public void onClick(View v) {
    ImportTask  task = new ImportTask(MainActivity.this, new OnCompletionListener() {
        public void onCompletion(Object result) {
            organization = (Organization) result;
            appendStatus(String.format("Imported organization '%s' having %d persons",
                    organization.getName(), organization.getStaff().size()));
        }
    });
    task.execute(dirName, fileName);

}
</code></pre>

<p>});</p>

<p>```</p>

<p>The <strong><em>ExportTask</em></strong> and <strong><em>ImportTask</em></strong> classes have logic where real Nano marshalling and unmarshalling magic happens:</p>

<h4>Export Logic</h4>

<p>``` java</p>

<p>@Override
protected File doInBackground(Object... args) {</p>

<pre><code>try {
    Organization organization = (Organization) args[0];
    String dirName = (String) args[1];
    String fileName = (String) args[2];
    File file = getFile(dirName,  fileName);
    Writer out = openForWrite(file);
    IWriter xmlWriter = NanoFactory.getXMLWriter();
    xmlWriter.write(organization, out);
    out.close();
    return file;
} catch (Exception e) {
    Log.d(LOG, "Failed to export. ", e);
    return null;
}
</code></pre>

<p>}</p>

<p>```</p>

<h4>Import Logic</h4>

<p>``` java</p>

<p>protected Organization doInBackground(Object... args) {</p>

<pre><code>try {
    String dirName  = (String) args[0];
    String fileName = (String) args[1];
    Reader in = openForRead(getFile(dirName,  fileName));
    IReader xmlReader = NanoFactory.getXMLReader();
    Organization org = xmlReader.read(Organization.class, in);
    in.close();
    return org;
} catch (Exception e) {
    Log.d(LOG, "Failed to import. ", e);
    return null;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Now you see the power of Nano : there are only 2 lines of marshalling and unmarshalling code, amazing!</p>

<h3>The Resulting XML</h3>

<p>It's easy to pull out the XML file from the SD card using the File Explorer of DDMS.</p>

<p>And here is an extract of its contents:</p>

<p>```xml</p>

<p>&lt;?xml version='1.0' encoding='utf-8' ?>
<organization count="88">
  <address></p>

<pre><code>&lt;street&gt;Street LY07&lt;/street&gt;
&lt;code&gt;VXUSB&lt;/code&gt;
&lt;city&gt;City SWT&lt;/city&gt;
</code></pre>

<p>  </address>
  <staff></p>

<pre><code>&lt;address&gt;
  &lt;street&gt;Street VRAW&lt;/street&gt;
  &lt;code&gt;6NEA8&lt;/code&gt;
  &lt;city&gt;City JLN&lt;/city&gt;
&lt;/address&gt;
&lt;name&gt;name ND4Q&lt;/name&gt;
</code></pre>

<p>  </staff>
  <staff></p>

<pre><code>&lt;address&gt;
  &lt;street&gt;Street XW8P&lt;/street&gt;
  &lt;code&gt;DNSP7&lt;/code&gt;
  &lt;city&gt;City PXP&lt;/city&gt;
&lt;/address&gt;
&lt;name&gt;name 5OMA&lt;/name&gt;
</code></pre>

<p>  </staff></p>

<p>...</p>

<p>  <name>Org IN3V9</name>
</organization></p>

<p>```</p>

<h3>The Source</h3>

<p>You can get the whole source of this demo project <a href="https://github.com/bulldog2011/nano/tree/master/sample/nano-and-android">here</a>, by the way, some source is adapted from <a href="http://blog.ribomation.com/2011/07/android-and-xml/">this post</a>, so part of the content of this post should be contributed to the author of that post.</p>

<h3>Conclusion</h3>

<p>Without automatic xml binding tool, data serialization and deserialization on Android is a tedious and time-consuming development task, needless to say later maintenance. The Nano xml binding framework can greatly accelerate xml based Android application development by automating the tedious and error-prone xml binding tasks, letting developers put more focus on their application logic instead of xml parsing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nano benchmark on android]]></title>
    <link href="http://bulldog2011.github.com/blog/2013/02/08/nano-benchmark-on-android/"/>
    <updated>2013-02-08T10:04:00+08:00</updated>
    <id>http://bulldog2011.github.com/blog/2013/02/08/nano-benchmark-on-android</id>
    <content type="html"><![CDATA[<p>Since I have built a light-weight XML/JSON binding framework tailored for Android platform, I want to test its performance on Android when compared with typical xml parsers on Android like SAX, DOM and Xml Pull, I will show you detailed test results in this post.</p>

<!--more-->


<p>I did the benchmark on my own mobile phone(it was quite cheap when I bought it:)), below is the spec of my mobile phone:</p>

<blockquote><ol>
<li>Brand : Samsung SCH-i559(Galaxy Mini)</li>
<li>CPU : ARM6 600MHz</li>
<li>RAM : 128MB</li>
<li>OS : Android 2.2.1</li>
</ol>
</blockquote>

<p>The payload I used is a faked person list, you can find the scheam <a href="https://github.com/bulldog2011/nano/blob/master/performance/nano-vs-jaxb/src/main/resources/person.xsd">here</a> and all payloads <a href="https://github.com/bulldog2011/nano/tree/master/performance/nano-on-android/assets">here</a>, I created these payloads with Nano and an auto-fake data generator called <a href="http://www.jemos.eu/projects/podam/">podam</a>. I tested 3 kinds of payload size :</p>

<blockquote><ol>
<li>10 records - 4KB xml, 2KB json</li>
<li>50 records - 17KB xml, 9KB json</li>
<li>300 records - 100KB xml, 50KB json</li>
</ol>
</blockquote>

<p>Basically, the size of json payload is almost half of the size of xml, this is because json has a more compact messsage format, the 300 records case is used for testing performance when dealing with big payload size.</p>

<p>The benchmark program itself is a typcial Android application, I adaped the test project from <a href="http://www.developer.com/ws/android/development-tools/Android-XML-Parser-Performance-3824221.htm">this</a> post, I added Nano cases and SAX, DOM, XML pull parsing cases in the benchmark program, you can download the whole benchmark program <a href="https://github.com/bulldog2011/nano/tree/master/performance/nano-on-android">here</a>.</p>

<p>Below is the UI of the benchmark application on PC emulator,</p>

<p><img src="/images/nano/nano-benchmark-app1.png" width="300" height="600">  <img src="/images/nano/nano-benchmark-app2.png" width="300" height="600"></p>

<p>following choices are avaliable for combined benchmark:</p>

<blockquote><ol>
<li>Thread Number - 1, 3, 5 threads</li>
<li>Payload Size - 10, 50, 300 records</li>
<li>Test Type - Nano Xml Read, Nano Json Read, SAX Read, DOM Read, XML Pull Read, Nano Xml Write, Nano Json Write</li>
</ol>
</blockquote>

<h3>Test Result</h3>

<p><strong><em>Note:</em></strong></p>

<blockquote><ol>
<li>the unit of test result is milliseconds</li>
<li>all test results are average of 20 runs.</li>
<li>for read test, the time includes file reading time, for write test, serialized content is only written in memory, not real file.</li>
</ol>
</blockquote>

<h4>1 Thread Read(Unmarshall) Test</h4>

<table>
   <tr>
      <td>[Records]</td>
      <td>[Nano XML]</td>
      <td>[Nano JSON]</td>
      <td>[RAW SAX]</td>
      <td>[RAW DOM]</td>
      <td>[RAW Pull]</td>
   </tr>
   <tr>
      <td>10</td>
      <td>34</td>
      <td>31</td>
      <td>18</td>
      <td>53</td>
      <td>24</td>
   </tr>
   <tr>
      <td>50</td>
      <td>133</td>
      <td>67</td>
      <td>70</td>
      <td>217</td>
      <td>90</td>
   </tr>
   <tr>
      <td>300</td>
      <td>724</td>
      <td>292</td>
      <td>388</td>
      <td>1318</td>
      <td>497</td>
   </tr>
</table>


<p></p>

<h4>3 Threads Read(Unmarshall) Test</h4>

<table>
   <tr>
      <td>[Records]</td>
      <td>[Nano XML]</td>
      <td>[Nano JSON]</td>
      <td>[RAW SAX]</td>
      <td>[RAW DOM]</td>
      <td>[RAW Pull]</td>
   </tr>
   <tr>
      <td>10</td>
      <td>102</td>
      <td>99</td>
      <td>53</td>
      <td>163</td>
      <td>76</td>
   </tr>
   <tr>
      <td>50</td>
      <td>405</td>
      <td>215</td>
      <td>206</td>
      <td>713</td>
      <td>272</td>
   </tr>
   <tr>
      <td>300</td>
      <td>2318</td>
      <td>951</td>
      <td>1186</td>
      <td>3812</td>
      <td>1599</td>
   </tr>
</table>


<p></p>

<h4>1 Thread Write(Marshall) Test</h4>

<table>
   <tr>
      <td>[Records] </td>
      <td>[Nano XML]</td>
      <td>[Nano JSON]</td>
   </tr>
   <tr>
      <td>10</td>
      <td>15</td>
      <td>23</td>
   </tr>
   <tr>
      <td>50</td>
      <td>61</td>
      <td>87</td>
   </tr>
   <tr>
      <td>300</td>
      <td>403</td>
      <td>508</td>
   </tr>
</table>


<p></p>

<h4>3 Threads Write(Marshall) Test</h4>

<table>
   <tr>
      <td>[Records] </td>
      <td>[Nano XML]</td>
      <td>[Nano JSON]</td>
   </tr>
   <tr>
      <td>10</td>
      <td>39</td>
      <td>60</td>
   </tr>
   <tr>
      <td>50</td>
      <td>118</td>
      <td>276</td>
   </tr>
   <tr>
      <td>300</td>
      <td>1290</td>
      <td>1664</td>
   </tr>
</table>


<p></p>

<h3>Conclusion</h3>

<h4>For Read Test:</h4>

<ol>
<li>Of all the tests, the best performers are Nano JSON and RAW SAX, this is not to say that the parsing speed of JSON is identical to SAX, but JSON message format is more compact, and its payload size is almost half of XML, leading to better performance.</li>
<li>Of all the tests, the worst performer is RAW DOM, this is obvious since DOM needs to put whole doc tree in memory and this will triger much GC on memory limited mobile device, leading to much slower speed.</li>
<li>The performance of Nano XML is in the middle, internally, Nano XML also use SAX paring technology, but it also needs to do automatic binding by reflection, this causes Nano XML to lose almost half of its performance, however, one the other hand, the maintainability and development effciency of Nano XML are much better than SAX.</li>
</ol>


<h4>For Write Test:</h4>

<p>Both Nano XML and Nano JSON perform quite good, in singe thread case they both can serialize 300 records(100KB xml, 50KB json) with less than half second.</p>

<p>Another finding is, there is almost a linear relationship between thread number and performance, when more threads are addded to benchmark, performance will degrade in proportion, considering the computation resource limitation of mobile device, it's not advisable to do multi-threading xml parsing on mobile device.</p>

<h3>My Recommendation:</h3>

<p>If your mobile application is performance critical, Nano JSON or RAW SAX is the way to go, I perfer Nano JSON since its automatic binding feature will have better maintainability and can impove development effciency a lot.<br/>
In other cases, Nano XML is also a good choice since it's a good balance among maintainability, development effciency, readability and performance. This is especially the case when you have a complex business domain, in such case, parsing a large amount of domain class will be a big development headache, never to say later maintenance, instead, the automatic code generation and binding features of Nano binding framework will be a big help in such case.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[schema driven nano binding]]></title>
    <link href="http://bulldog2011.github.com/blog/2013/02/07/schema-driven-nano-binding/"/>
    <updated>2013-02-07T20:32:00+08:00</updated>
    <id>http://bulldog2011.github.com/blog/2013/02/07/schema-driven-nano-binding</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/bulldog2011/nano">Nano</a> is a light weight xml/json binding framework targeting Android platform, in this post, I will show you how to use Nano and the accompanying compiler tool <a href="https://github.com/bulldog2011/mxjc">mxjc</a> together to do schema driven xml or json data binding - similar to the development process using JAXB and XJC.</p>

<!--more-->


<h3>The Big Picture</h3>

<p><img class="center" src="/images/nano/nano-binding.png" width="400" height="400"></p>

<p>A picture is worth a thousand words, a typical schema driven xml data binding development includes two main phases:</p>

<blockquote><ol>
<li><strong><em>Build Time</em></strong> - in this phase, we authorize xml scheam or xsd first, the schema specifies the metadata of our business domain, this is the single source of truth, later code generation all depends on the scheam, only if the scheam changes, then we need to regenerate source code. With schema specified, we use the mxjc schema binding compiler to compile the scheam into Nano bindable classes, mxjc is based on JAXB xjc, so its usage is similar to xjc. Classes generated by mxjc will be annotated with Nano annotations, these annotations specify the mapping between pojo and xml, they will later be scanned by Nano binding framework to guide the real marshalling or unmarshalling at runtime.</li>
<li><strong><em>Runtime time</em></strong> - in this phase, we have Nano bindable domain class in hand, what's left is to do marshalling or unmarshalling according to real needs, by leveraging Nano binding framework. Nano is a middle man between XML/JSON document and java object, when objects or pojos are fed into the Nano binding framework, it can marshall them or serialize them into either XML or JSON content, and when XML or JSON content is fed into the Nano binding framework, it can unmarshall or deserialize them into objects or pojos.</li>
</ol>
</blockquote>

<p>By the way, scheam driven development is good for some scenario with complex business domain, without formal schema and automated code generation, the manual written code base will be very hard to maintain. However, when your use case is simple, it's not necessary to begin with scheam, just write your domian class then annotate with Nano annations is also workable.</p>

<h3>A Zoo Sample</h3>

<p>I've create an ant project to demo the scheam driven developmeng with Nano and mxjc, you can find the project <a href="https://github.com/bulldog2011/nano/tree/master/sample/schema-driven">here</a>, you can download the whole project and run it with Ant(suppose you have Ant installed).</p>

<p>Belew is the Ant build file which includes all scheam driven development stets mentioned above:</p>

<p>``` xml</p>

<p>&lt;?xml version="1.0" standalone="yes"?></p>

<p><project basedir="." default="run">
  <property name="sample.home" value="." />
  <path id="classpath"></p>

<pre><code>&lt;pathelement path="classes" /&gt;
&lt;fileset dir="${sample.home}" includes="lib/mxjc/*.jar" /&gt;
&lt;fileset dir="${sample.home}" includes="lib/nano/*.jar" /&gt;
</code></pre>

<p>  </path>
  <taskdef name="mxjc" classname="com.leansoft.mxjc.MXJCTask"></p>

<pre><code>&lt;classpath refid="classpath" /&gt;
</code></pre>

<p>  </taskdef></p>

<p>  <!--compile Java source files-->
  <target name="compile" description="Compile all Java source files"></p>

<pre><code>&lt;echo message="Compiling the schema..." /&gt;
&lt;mkdir dir="gen-src" /&gt;
&lt;mxjc schema="schema/zoo.xsd" package="com.leansoft.nano.zoo" destdir="gen-src" removeOldOutput="yes"&gt;
  &lt;produces dir="gen-src/com/leansoft/nano/zoo" includes="**/*.java" /&gt;
&lt;/mxjc&gt;
&lt;echo message="Compiling the java source files..." /&gt;
&lt;mkdir dir="classes" /&gt;
&lt;javac destdir="classes" debug="on"&gt;
  &lt;src path="src" /&gt;
  &lt;src path="gen-src" /&gt;
  &lt;classpath refid="classpath" /&gt;
&lt;/javac&gt;
</code></pre>

<p>  </target></p>

<p>  <target name="run" depends="compile" description="Run the sample app"></p>

<pre><code>&lt;echo message="Running the sample application..." /&gt;
&lt;java classname="com.leansoft.nano.sample.ZooExample" fork="true"&gt;
  &lt;classpath refid="classpath" /&gt;
&lt;/java&gt;
</code></pre>

<p>  </target></p>

<p>  <target name="clean" description="Deletes all the generated artifacts."></p>

<pre><code>&lt;delete dir="gen-src" /&gt;
&lt;delete dir="classes" /&gt;
</code></pre>

<p>  </target>
</project></p>

<p>```</p>

<p>mxjc provides an Ant task called MXJCTask, similar to xjc ant task, mxjc ant task can also auto-generate source from scheam driven by Ant.</p>

<p>Following the xml scheam(xsd):</p>

<p>``` xml</p>

<p>&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  &lt;xsd:element name="zoo" type="zooInfo"/>
  &lt;xsd:element name="comment" type="xsd:string"/>
  &lt;xsd:complexType name="zooInfo"></p>

<pre><code>&lt;xsd:sequence&gt;
  &lt;xsd:element name="zooName" type="xsd:string"/&gt;
  &lt;xsd:element name="zooId" type="xsd:int"/&gt;
  &lt;xsd:element name="animals" type="Animals"/&gt;
&lt;/xsd:sequence&gt;
</code></pre>

<p>  &lt;/xsd:complexType></p>

<p>  &lt;xsd:complexType name="Animals"></p>

<pre><code>&lt;xsd:sequence&gt;
  &lt;xsd:element name="animal" minOccurs="1" maxOccurs="unbounded"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="animalName" type="xsd:string"/&gt;
        &lt;xsd:element name="animalType" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;
&lt;/xsd:sequence&gt;
</code></pre>

<p>  &lt;/xsd:complexType>
&lt;/xsd:schema></p>

<p>```</p>

<p>The XML document which we are going to read and print in console:</p>

<p>``` xml</p>

<p>&lt;?xml version="1.0"?>
<zoo>
  <zooName>Vandalur Zoo</zooName>
  <zooId>12321</zooId>
  <animals></p>

<pre><code>&lt;animal&gt;
  &lt;animalName&gt;Lion&lt;/animalName&gt;
  &lt;animalType&gt;Wild&lt;/animalType&gt;
&lt;/animal&gt;
&lt;animal&gt;
  &lt;animalName&gt;Dog&lt;/animalName&gt;
  &lt;animalType&gt;Domestic&lt;/animalType&gt;
&lt;/animal&gt;
&lt;animal&gt;
  &lt;animalName&gt;White Tiger&lt;/animalName&gt;
  &lt;animalType&gt;Wild&lt;/animalType&gt;
&lt;/animal&gt;
</code></pre>

<p>  </animals>
</zoo></p>

<p>```</p>

<p>Following is the main java code to read the xml file, output some content, and then write the whole objects into json output.</p>

<p>``` java</p>

<p>package com.leansoft.nano.sample;</p>

<p>import java.io.FileInputStream;
import java.util.List;</p>

<p>import com.leansoft.nano.IReader;
import com.leansoft.nano.IWriter;
import com.leansoft.nano.NanoFactory;
import com.leansoft.nano.zoo.Animals;
import com.leansoft.nano.zoo.ZooInfo;
import com.leansoft.nano.zoo.animals.Animal;</p>

<p>public class ZooExample {</p>

<pre><code>public static void main(String[] args) {
    try {

        IReader xmlReader = NanoFactory.getXMLReader();

        ZooInfo zooInfo = xmlReader.read(ZooInfo.class, new FileInputStream("xml/zoo.xml"));

        System.out.println("Output after xml read - ");
        System.out.println("Zoo Name: " + zooInfo.getZooName());
        System.out.println("Zoo Id: " + zooInfo.getZooId());

        Animals animals = zooInfo.getAnimals();
        List&lt;Animal&gt; animalsList = animals.getAnimal();

        for (Animal animal : animalsList) {
            System.out.println("\t" + animal.getAnimalName());
            System.out.println("\t\t" + animal.getAnimalType());
        }

        IWriter xmlWriter = NanoFactory.getJSONWriter();

        System.out.println("Output after json write - ");
        xmlWriter.write(zooInfo, System.out);


    } catch(Exception e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Output</p>

<p>```</p>

<p>Output after xml read -
Zoo Name: Vandalur Zoo
Zoo Id: 12321</p>

<pre><code>Lion
    Wild
Dog
    Domestic
White Tiger
    Wild
</code></pre>

<p>Output after json write -
{"zoo": {</p>

<pre><code>"animals": {"animal": [
    {
        "animalName": "Lion",
        "animalType": "Wild"
    },
    {
        "animalName": "Dog",
        "animalType": "Domestic"
    },
    {
        "animalName": "White Tiger",
        "animalType": "Wild"
    }
]},
"zooId": 12321,
"zooName": "Vandalur Zoo"
</code></pre>

<p>}}</p>

<p>```</p>

<h3>Conclusion</h3>

<p>When used properly, scheam driven development can greatly improve agaility in development, and just as I have showed in the post, Nano with mxjc supports scheam driven development smoothly, you may tell me that you would rather choose JAXB to do scheam driven development, I admit that JAXB is more mature and feature-rich than Nano, but one cool thing of Nano is it supports Android platform while JAXB does not, Nano is just tailored for Android platform, in later posts, I will show you how to practice scham driven data binding on Android platform, it's facinating, stay tuned.</p>
]]></content>
  </entry>
  
</feed>
